<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <canvas></canvas>
    <script>
        const canvas = document.querySelector("canvas");
        const ctx = canvas.getContext("2d");
        const cameraParam = { position: [0, 25, 2], angle: [1.4, 0, 0] }; // カメラのパラメーター
        const inputKey = [];
        const keyCodes = [68, 65, 82, 70, 87, 83, 38, 40, 69, 81, 67, 90]; // 操作キーのコード
        const cameraSpeed = 1; // 1fあたりの移動量
        const cameraRotateSpped = 0.03; // 1fあたりの回転量
        let ww, wh;

        function animationLoop() {
            cameraUpdate();
            draw();
            requestAnimationFrame(animationLoop);
        }

        // 描画する
        function draw() {
            ctx.clearRect(-ww / 2, -wh / 2, ww, wh);
            for (let x = -30; x < 30; x += 0.2) {
                for (let z = -20; z < 20; z += 0.2) {
                    const scaled = scaling(x, 0, z);
                    if (scaled === undefined || scaled[0] < -ww / 2 || ww < scaled[0] || scaled[1] < -wh / 2 || wh < scaled[1]) continue;
                    if (calcMandelbrotSet(x / 15, z / 15)) {
                        ctx.beginPath();
                        ctx.arc(...scaled, 1.3, 0, Math.PI * 2);
                        ctx.fill();

                    }
                }
            }
        }

        // マンデルブロ集合に属するか調べる
        function calcMandelbrotSet(x, y) {
            let X = x, Y = y, c = 0;
            while (c < 99) {
                if (X * X + Y * Y > 4) return false;
                z = X * X - Y * Y + x;
                Y = 2 * X * Y + y;
                X = z;
                c++;
            }
            return true;
        }
        // 2次元好きなんだよね。特に画像とか見るの
        // マンデルブロ集合(ハウスドルフ次元が2)っていいよね〜

        // 描画用にスケーリングする
        function scaling(x, y, z) {
            x -= cameraParam.position[0];
            y -= cameraParam.position[1];
            z -= cameraParam.position[2];
            [x, y, z] = rotate([x, y, z]);
            if (z > 0) return [x / z * 350, -y / z * 350]; // yは正が下なので正負反転させる
        }

        // キャンバスを画面に合わせてリサイズする
        function resizeCanvas() {
            ww = window.innerWidth;
            wh = window.innerHeight;
            canvas.width = ww
            canvas.height = wh;
            ctx.translate(ww / 2, wh / 2);
        }

        // x,y,zそれぞれを軸として回転移動させる
        function rotate(position) {
            [position[1], position[2]] = rotateMove(position[1], position[2], cameraParam.angle[0]);
            [position[0], position[2]] = rotateMove(position[0], position[2], cameraParam.angle[1]);
            [position[0], position[1]] = rotateMove(position[0], position[1], cameraParam.angle[2]);
            return position
        }

        // 対象の2点を回転移動させる
        function rotateMove(p1, p2, angle) {
            return [p1 * Math.cos(angle) + p2 * Math.sin(angle), p2 * Math.cos(angle) - p1 * Math.sin(angle)];
        }

        // 入力に応じてカメラのパラメーターを更新する
        function cameraUpdate() {
            // 機能追加のときに面倒なので当分は繰り返しではなく直書き
            if (inputKey[0]) cameraParam.position[0] += cameraSpeed;
            if (inputKey[1]) cameraParam.position[0] -= cameraSpeed;
            if (inputKey[2]) cameraParam.position[1] += cameraSpeed;
            if (inputKey[3]) cameraParam.position[1] -= cameraSpeed;
            if (inputKey[4]) cameraParam.position[2] += cameraSpeed;
            if (inputKey[5]) cameraParam.position[2] -= cameraSpeed;
            if (inputKey[6]) cameraParam.angle[0] -= cameraRotateSpped;
            if (inputKey[7]) cameraParam.angle[0] += cameraRotateSpped;
            if (inputKey[8]) cameraParam.angle[1] -= cameraRotateSpped;
            if (inputKey[9]) cameraParam.angle[1] += cameraRotateSpped;
            if (inputKey[10]) cameraParam.angle[2] -= cameraRotateSpped;
            if (inputKey[11]) cameraParam.angle[2] += cameraRotateSpped;
        }

        window.addEventListener("load", () => {
            resizeCanvas();
            animationLoop();
        });

        window.addEventListener("resize", resizeCanvas);

        // 押されたキーを取得し、配列に保存する
        document.addEventListener("keydown", e => {
            const inputKeyCode = keyCodes.indexOf(e.keyCode);
            if (inputKeyCode >= 0) {
                inputKey[inputKeyCode] = true;
            }
        });

        // 離されたキーを取得し、配列から取り出す
        document.addEventListener("keyup", e => {
            const inputKeyCode = keyCodes.indexOf(e.keyCode);
            if (inputKeyCode >= 0) {
                inputKey[inputKeyCode] = false;
            }
        });
    </script>
</body>

</html>
